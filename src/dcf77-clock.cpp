/*
 * DCF77 Radio Clock Application for RP2040
 *
 * Copyright (C) 2023 JÃ¼rgen Reuter
 *
 * This file is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published
 * by the Free Software Foundation; either version 2 of the License,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that contains a
 * configuration script generated by Autoconf, you may include it
 * under the same distribution terms that you use for the rest of that
 * program.
 *
 * For updates and more info or contacting the author, visit:
 * <https://github.com/soundpaint>
 *
 * Author's web site: www.juergen-reuter.de
 */

#include "dcf77-clock.hpp"

#include <cstring>
#include "pico/stdlib.h"
#include "hardware/i2c.h"
#include "hardware/rtc.h"

const uint16_t
DCF77_clock::GPIO_I2C_SDA_PIN = 20u;

const uint16_t
DCF77_clock::GPIO_I2C_SCL_PIN = 21u;

DCF77 *
DCF77_clock::dcf77;

bool
DCF77_clock::call_bit = false;

bool
DCF77_clock::dst_announce = false;

bool
DCF77_clock::dst = false;

uint8_t
DCF77_clock::estimated_signal_quality = 0;

uint64_t
DCF77_clock::last_updated_wallclock_us = 0;

GUI *
DCF77_clock::gui;

void
DCF77_clock::gpio_cleanup()
{
  for (uint8_t gpio = 0; gpio < 32; gpio++) {
    gpio_deinit(gpio);
  }
}

void
DCF77_clock::init_i2c()
{
  i2c_init(i2c_default, 100 * 1000);
  gpio_set_function(GPIO_I2C_SDA_PIN, GPIO_FUNC_I2C);
  gpio_set_function(GPIO_I2C_SCL_PIN, GPIO_FUNC_I2C);
  gpio_pull_up(GPIO_I2C_SDA_PIN);
  gpio_pull_up(GPIO_I2C_SCL_PIN);
}

void
DCF77_clock::init_gui()
{
  gui = new GUI();
  if (gui) {
    if (gui->init()) {
      printf("GUI initialized\n");
    } else {
      delete gui;
      gui = 0;
    }
  }
  if (!gui) {
    printf("warning: failed initializing GUI\n");
  }
}

void
DCF77_clock::init_dcf77()
{
  dcf77 = new DCF77();
  if (dcf77) {
    if (dcf77->init(&receive_data)) {
      printf("DCF77 receiver initialized\n");
    } else {
      delete dcf77;
      dcf77 = 0;
    }
  } else {
    dcf77 = 0;
  }
  if (!dcf77) {
    printf("warning: failed initalizing DCF77 receiver\n");
  }
}

void
DCF77_clock::receive_data(const uint64_t target_wallclock_us,
                          DCF77::time_code_t &time_code)
{
  printf("updating RTC: %02d:%02d:%02d -- %02d.%02d.%04d\n",
         time_code.hour, time_code.min, 0,
         time_code.day, time_code.month, time_code.year);
  printf("%lld microseconds ahead time\n", target_wallclock_us - time_us_64());
  datetime_t datetime = {
    .year = time_code.year,
    .month = time_code.month,
    .day = time_code.day,
    .dotw = time_code.dotw,
    .hour = time_code.hour,
    .min = time_code.min,
    .sec = 0,
  };
  /*
   * TODO: Do busy wait for more exact setting RTC, but not inside
   * this interrupt handling code, since it will interfere with
   * receiving the next data bit from the DCF77 signal.
   */
  //busy_wait_until(target_wallclock_us);
  if (!rtc_set_datetime(&datetime)) {
    printf("warning: failed updating RTC due to invalid datetime\n");
  }
  // TODO: log civil warning bits
  call_bit = time_code.call_bit;
  dst_announce = time_code.dst_announce;
  dst = time_code.dst;
  estimated_signal_quality = time_code.estimated_signal_quality;
  last_updated_wallclock_us = target_wallclock_us;
}

int8_t
DCF77_clock::compare_datetime(const datetime_t &datetime1,
                              const datetime_t &datetime2)
{
  if (datetime1.year < datetime2.year) return -1;
  if (datetime1.year > datetime2.year) return +1;
  if (datetime1.month < datetime2.month) return -1;
  if (datetime1.month > datetime2.month) return +1;
  if (datetime1.day < datetime2.day) return -1;
  if (datetime1.day > datetime2.day) return +1;
  if (datetime1.hour < datetime2.hour) return -1;
  if (datetime1.hour > datetime2.hour) return +1;
  if (datetime1.min < datetime2.min) return -1;
  if (datetime1.min > datetime2.min) return +1;
  if (datetime1.sec < datetime2.sec) return -1;
  if (datetime1.sec > datetime2.sec) return +1;
  return 0;
}

void
DCF77_clock::loop()
{
  gui->clear();
  gpio_init(PICO_DEFAULT_LED_PIN);
  gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);

  datetime_t prev_datetime;
  memset(&prev_datetime, 0, sizeof(prev_datetime));
  while (1) {
    datetime_t datetime;
    rtc_get_datetime(&datetime);
    if (compare_datetime(prev_datetime, datetime)) {
      gui->update(datetime, dst, call_bit);
      prev_datetime = datetime;
    }
    sleep_ms(200);
  }
}

void
DCF77_clock::init()
{
  stdio_init_all();
  rtc_init();
  init_i2c();
  init_gui();
  init_dcf77();
}

void
DCF77_clock::deinit()
{
  delete dcf77;
  dcf77 = 0;
  delete gui;
  gui = 0;
  gpio_cleanup();
}

void
DCF77_clock::main()
{
  init();
  loop();
  deinit();
}

int main(void)
{
  DCF77_clock::main();
}

/*
 * Local variables:
 *   mode: c++
 *  coding: utf-8
 * End:
 */
