/*
 * DCF77 Radio Clock Driver for RP2040
 *
 * Copyright (C) 2023 JÃ¼rgen Reuter
 *
 * This file is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published
 * by the Free Software Foundation; either version 2 of the License,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that contains a
 * configuration script generated by Autoconf, you may include it
 * under the same distribution terms that you use for the rest of that
 * program.
 *
 * For updates and more info or contacting the author, visit:
 * <https://github.com/soundpaint>
 *
 * Author's web site: www.juergen-reuter.de
 */

#include "dcf77.hpp"

#include <cstdio>
#include <exception>
#include "pico/stdlib.h"
#include "hardware/gpio.h"
#include "hardware/rtc.h"

const uint16_t
DCF77::GPIO_LED_PIN = 25u;

const uint16_t
DCF77::GPIO_TCO_PIN = 16u;

const datetime_t
DCF77::START_DATETIME = {
  .year = 1,
  .month = 1,
  .day = 1,
  .dotw = 6,
  .hour = 0,
  .min = 0,
  .sec = 0,
};

// no leap-year days per month
const uint8_t
DCF77::DAYS_PER_MONTH[] = {
  31, 30, 28, 30, 31, 30, 31, 31, 30, 31, 30, 31,
};

const char *
DCF77::gpio_irq_str[] = {
  "LEVEL_LOW",  // 0x1
  "LEVEL_HIGH", // 0x2
  "EDGE_FALL",  // 0x4
  "EDGE_RISE",  // 0x8
};

DCF77 *
DCF77::instance = 0;

bool
DCF77::inverse_tco = false;

bool
DCF77::display_pulses = false;

DCF77::data_receive_callback_t
DCF77::data_receive_callback = 0;

// assumed index of next bit to receive
uint8_t
DCF77::bit_index = 0;

// bits for seconds 0..59 plus optional leap second
uint8_t
DCF77::bit[60];

uint64_t
DCF77::bit_time_us[60];

bool
DCF77::level_low = false;

uint64_t
DCF77::prev_fall_time_us = 0;

uint64_t
DCF77::prev_rise_time_us = 0;

DCF77::DCF77() : DCF77(GPIO_TCO_PIN, true, true)
{
}

DCF77::DCF77(const uint16_t gpio_tco_pin, const bool inverse_tco,
             const bool display_pulses)
  : _gpio_tco_pin(gpio_tco_pin),
    _inverse_tco(inverse_tco),
    _display_pulses(display_pulses)
{
}

void
DCF77::render_gpio_event(char *buffer, const uint32_t events)
{
  bool first_event = true;
  for (uint32_t event_type  = 0; event_type < 4; event_type++) {
    const uint mask = (1 << event_type);
    if (events & mask) {
      if (!first_event) {
        *buffer++ =',';
        *buffer++ = ' ';
      }
      const char *event_str = gpio_irq_str[event_type];
      while (*event_str != '\0') {
        *buffer++ = *event_str++;
      }
      first_event = false;
    }
  }
  *buffer++ ='\0';
}

bool
DCF77::check_parity(const uint8_t index_start, const uint8_t index_parity)
{
  uint8_t bit_count = 0;
  for (uint8_t index = index_start; index < index_parity; index++) {
    bit_count ^= bit[index];
  }
  return (bit_count ^= bit[index_parity]) & 0x1;
}

bool
DCF77::day_overflow(const uint8_t day, const uint8_t month)
{
  // TODO: Leap years
  return day > DAYS_PER_MONTH[month - 1];
}

bool
DCF77::serve_time_code(const uint64_t update_wallclock_us)
{
  if (bit[0]) {
    printf("update failed: invalid minute start marker\n");
    return false;
  }
  if (bit_index != (59 + bit[19])) {
    printf("update failed: unexpected value of bit index\n");
    return false;
  }
  const uint16_t civil_warning_bits =
    (bit[1] << 0) | (bit[2] << 1) | (bit[3] << 2) | (bit[4] << 3) |
    (bit[5] << 4) | (bit[6] << 5) | (bit[7] << 6) | (bit[8] << 7) |
    (bit[9] << 8) | (bit[10] << 9) | (bit[11] << 10) | (bit[12] << 11) |
    (bit[13] << 12) | (bit[14] << 13);
  if (!bit[17] && !bit[18]) {
    printf("update failed: invalid DST mode '00'\n");
    return false;
  }
  if (bit[17] && bit[18]) {
    printf("update failed: invalid DST mode '11'\n");
    return false;
  }
  const bool call_bit = bit[15];
  const bool dst_announce = bit[16];
  const bool dst = bit[17];
  if (!bit[20]) {
    printf("update failed: invalid time start marker\n");
    return false;
  }
  if (check_parity(21, 28)) {
    printf("update failed: parity error: minute\n");
    return false;
  }
  if (check_parity(29, 35)) {
    printf("update failed: parity error: hour\n");
    return false;
  }
  if (check_parity(36, 58)) {
    printf("update failed: parity error: date\n");
    return false;
  }
  const int8_t min =
    1 * (bit[21] | (bit[22] << 1) | (bit[23] << 2) | (bit[24] << 3)) +
    10 * (bit[25] | (bit[26] << 1) | (bit[27] << 2));
  if (min > 59) {
    printf("update failed: minute out of range\n");
    return false;
  }
  const int8_t hour =
    1 * (bit[29] | (bit[30] << 1) | (bit[31] << 2) | (bit[32] << 3)) +
    10 * (bit[33] | (bit[34] << 1));
  if (hour > 23) {
    printf("update failed: hour out of range\n");
    return false;
  }
  const int8_t day =
    1 * (bit[36] | (bit[37] << 1) | (bit[38] << 2) | (bit[39] << 3)) +
    10 * (bit[40] | (bit[41] << 1));
  if (day > 30) {
    printf("update failed: day out of range\n");
    return false;
  }
  const int32_t weekday =
    bit[42] | (bit[43] << 1) | (bit[44] << 2);
  if ((weekday < 1) || (weekday > 7)) {
    printf("update failed: day of the week out of range\n");
    return false;
  }
  const int8_t dotw = (int8_t)(weekday % 7);
  const int8_t month =
    1 * (bit[45] | (bit[46] << 1) | (bit[47] << 2) | (bit[48] << 3)) +
    10 * bit[49];
  if (month > 11) {
    printf("update failed: month out of range\n");
    return false;
  }
  const int16_t year =
    2000 +
    1 * (bit[50] | (bit[51] << 1) | (bit[52] << 2) | (bit[53] << 3)) +
    10 * (bit[54] | (bit[55] << 1) | (bit[56] << 1) | (bit[57] << 1));
  if (year > 2099) {
    printf("update failed: year out of range\n");
    return false;
  }
  const uint8_t estimated_signal_quality = 0; // TODO
  time_code_t time_code = {
    .civil_warning_bits = civil_warning_bits,
    .call_bit = call_bit,
    .dst_announce = dst_announce,
    .dst = dst,
    .min = min,
    .hour = hour,
    .day = day,
    .dotw = dotw,
    .month = month,
    .year = year,
    .estimated_signal_quality = estimated_signal_quality,
  };
  const uint64_t target_wallclock_us = update_wallclock_us + 1000000;
  if (data_receive_callback) {
    (*data_receive_callback)(target_wallclock_us, time_code);
  }
  return true;
}

void
DCF77::add_bit(const uint8_t value, const uint64_t bit_wallclock_us)
{
  if (bit_index > 59) {
    printf("bad signal: end of minute not detected\n");
    bit_index = 0;
    return;
  }
  bit_time_us[bit_index] = bit_wallclock_us;
  bit[bit_index++] = value;
  printf("now valid sequence of %d bits received\n", bit_index);
}

void
DCF77::handle_falling_edge(const uint64_t edge_wallclock_us)
{
  const uint64_t delta = edge_wallclock_us - prev_fall_time_us;
  printf("falling edge: delta=%ldms\n", (uint32_t)(delta / 1000));
  prev_fall_time_us = edge_wallclock_us;
  if (delta < 900000) {
    printf("falling edge: bad signal: pulse too narrow (<900ms)\n");
    bit_index = 0;
    return;
  } else if (delta > 2100000) {
    printf("falling edge: bad signal: pulse too wide (>2100ms)\n");
    bit_index = 0;
    return;
  } else if ((delta > 1100000) && (delta < 1900000)) {
    printf("falling edge: bad signal: not clear 1 or 2 seconds pulse\n");
    bit_index = 0;
    return;
  } else if (delta < 1500000) {
    printf("falling edge: no minute end marker; continue regularly\n");
    return;
  } else {
    printf("falling edge: minute end marker => update time\n");
    serve_time_code(edge_wallclock_us);
    bit_index = 0;
  }
}

void
DCF77::handle_rising_edge(const uint64_t edge_wallclock_us)
{
  const uint64_t delta = edge_wallclock_us - prev_fall_time_us;
  printf("rising edge: delta=%ldms\n", (uint32_t)(delta / 1000));
  prev_rise_time_us = edge_wallclock_us;
  if (delta < 50000) {
    printf("rising edge: bad signal: pulse too narrow (<50ms)\n");
    bit_index = 0;
    return;
  } else if (delta > 250000) {
    printf("rising edge: bad signal: pulse too wide (>250ms)\n");
    bit_index = 0;
    return;
  } else if (delta < 150000) {
    printf("rising edge: detected narrow pulse\n");
    add_bit(0, edge_wallclock_us);
  } else {
    printf("rising edge: detected wide pulse\n");
    add_bit(1, edge_wallclock_us);
  }
}

void
DCF77::update_led_status(const bool high_level)
{
  gpio_put(GPIO_LED_PIN, high_level);
}

void
DCF77::tco_edge_handle(const uint gpio, const uint32_t events)
{
  const uint64_t edge_wallclock_us = time_us_64();
  const bool high_level = gpio_get(gpio) != inverse_tco;
  if (display_pulses) {
    update_led_status(!high_level);
  }
  const bool falling = inverse_tco ?
    events & GPIO_IRQ_EDGE_RISE :
    events & GPIO_IRQ_EDGE_FALL;
  const bool rising = inverse_tco ?
    events & GPIO_IRQ_EDGE_FALL :
    events & GPIO_IRQ_EDGE_RISE;
  if (falling && rising) {
    printf("warning: bad signal: falling and raising\n");
  } else {
    if (falling && high_level) {
      printf("bad signal: high level after falling\n");
      return;
    }
    if (rising && !high_level) {
      printf("bad signal: low level after rising\n");
      return;
    }
  }
  if (rising) {
    handle_rising_edge(edge_wallclock_us);
  } else if (falling) {
    handle_falling_edge(edge_wallclock_us);
  } else {
    printf("bad signal: neither falling, nor rising\n");
    return;
  }
  // TODO: Instancify static methods:
  //
  //if (!instance) {
  //  printf("no DCF77 instance\n");
  //  return;
  //}
  //static char event_str[128];
  //render_gpio_event(event_str, events);
  //printf("GPIO %d %s\n", gpio, event_str);

  // TODO: race condition: make this code thread-safe
  //instance->tco_edge_handle(gpio, events);
}

void
DCF77::do_tco_edge_handle(__unused const uint gpio,
                          __unused const uint32_t events)
{
  if (gpio != _gpio_tco_pin) {
    printf("GPIO %d != %d\n", gpio, _gpio_tco_pin);
    return;
  }
  // TODO
}

bool
DCF77::init(data_receive_callback_t data_receive_callback)
{
  // for now, there may be only a single DCF77 instance
  if (instance) {
    // FIXME: race condition: make this code thread-safe
    printf("init error: DCF77 instance already\n");
    throw new std::exception();
  }
  instance = this;
  inverse_tco = _inverse_tco;
  display_pulses = _display_pulses;
  DCF77::data_receive_callback = data_receive_callback;
  datetime_t time = START_DATETIME;
  rtc_set_datetime(&time);
  gpio_set_irq_enabled_with_callback(_gpio_tco_pin,
                                     GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL,
                                     true, &tco_edge_handle);
  gpio_init(_gpio_tco_pin);
  gpio_set_dir(_gpio_tco_pin, GPIO_IN);
  return true;
}

/*
 * Local variables:
 *   mode: c++
 *  coding: utf-8
 * End:
 */
